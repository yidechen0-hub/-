[2561重排水果](https://leetcode.cn/problems/rearranging-fruits)

~~~cpp
class Solution {
public:
    long long minCost(vector<int>& basket1, vector<int>& basket2) {
        unordered_map<int, int> cnt;
        // 技巧：
        // 假设basket1中的个数大于basket2中的个数
        // basket1中的个数：s1 = a+b
        // basket2中的个数: s2 = a
        // 所以mid = a+b/2,所以多于的个数为s1-mid = b/2
        // 即只需要记录basket1和basket2中相同数字的差值的一半
        // 即只需要一个map就可以了
        for (int i = 0; i < basket1.size(); i++) {
            cnt[basket1[i]]++;
            cnt[basket2[i]]--; // 交集元素互相抵消
        }

        vector<int> a, b;
        int mn = INT_MAX;
        for (auto [x, c] : cnt) {
            if (c % 2 != 0) { // 奇数无法均分
                return -1;
            }
            mn = min(mn, x);
            // 剩余元素的一半放入 a 或者 b
            if (c > 0) {
                for (int i = 0; i < c / 2; i++) {
                    a.push_back(x);
                }
            } else {
                for (int i = 0; i < -c / 2; i++) {
                    b.push_back(x);
                }
            }
        }

        ranges::sort(a);
        ranges::sort(b, greater());

        long long ans = 0;
        for (int i = 0; i < a.size(); i++) {
            ans += min({a[i], b[i], mn * 2}); // 累加最小交换代价
        }
        return ans;
    }
};
~~~

~~~kotlin
import kotlin.math.min

fun minCost(basket1: IntArray, basket2: IntArray): Long {
    val cnt = mutableMapOf<Int, Int>()
    val n = basket1.size

    // 统计每个元素在两个篮子中的数量差
    for (i in 0 until n) {
        cnt[basket1[i]] = cnt.getOrDefault(basket1[i], 0) + 1
        cnt[basket2[i]] = cnt.getOrDefault(basket2[i], 0) - 1
    }

    val a = mutableListOf<Int>()
    var mn = Int.MAX_VALUE

    for ((x, c) in cnt) {
        if (c % 2 != 0) {
            return -1L
        }
        mn = min(mn, x)
        repeat(kotlin.math.abs(c) / 2) {
            a.add(x)
        }
    }

    // 使用排序代替 nth_element (Kotlin 标准库没有直接的 nth_element)
    // 但为了效率，我们可以使用排序，因为后续需要访问前一半元素
    a.sort()

    var ans = 0L
    val halfSize = a.size / 2
    for (i in 0 until halfSize) {
        ans += min(a[i], mn * 2)
    }
    return ans
}
~~~

```kotlin
import kotlin.math.min

fun minCost(basket1: IntArray, basket2: IntArray): Long {
    val cnt = mutableMapOf<Int, Int>()
    val n = basket1.size

    // 统计每个元素在两个篮子中的数量差
    for (i in 0 until n) {
        cnt[basket1[i]] = cnt.getOrDefault(basket1[i], 0) + 1
        cnt[basket2[i]] = cnt.getOrDefault(basket2[i], 0) - 1
    }

    val a = mutableListOf<Int>()
    var mn = Int.MAX_VALUE

    for ((x, c) in cnt) {
        if (c % 2 != 0) {
            return -1L
        }
        mn = min(mn, x)
        repeat(kotlin.math.abs(c) / 2) {
            a.add(x)
        }
    }

    // 使用排序代替 nth_element (Kotlin 标准库没有直接的 nth_element)
    // 但为了效率，我们可以使用排序，因为后续需要访问前一半元素
    a.sort()

    var ans = 0L
    val halfSize = a.size / 2
    for (i in 0 until halfSize) {
        ans += min(a[i], mn * 2)
    }
    return ans
}
```

**说明：**

1.  **数据结构转换**：将 `vector<int>` 转换为 `IntArray`，`unordered_map` 转换为 `MutableMap<Int, Int>`。
2.  **循环**：使用 Kotlin 的 `for (i in 0 until n)` 和 `for ((x, c) in cnt)` 语法。
3.  **Map 操作**：使用 `getOrDefault` 处理键不存在的情况。
4.  **绝对值和重复**：使用 `kotlin.math.abs` 和 `repeat` 函数。
5.  **最小值**：使用 `kotlin.math.min`。
6.  **nth_element 替代**：Kotlin 标准库没有直接等同于 C++ `nth_element` 的函数。这里使用 `sort()` 代替。虽然 `nth_element` 的平均复杂度是 O(n)，而 `sort()` 是 O(n log n)，但对于这个特定问题，由于我们最终需要访问排序后数组的前半部分元素，`sort()` 在实践中可能足够高效，且代码更清晰。如果性能是关键且数据量大，可以考虑实现一个快速选择算法。
7.  **返回值**：确保返回 `Long` 类型（`-1L`, `0L`）。
8.  **常量**：使用 `Int.MAX_VALUE` 代替 `INT_MAX`。
